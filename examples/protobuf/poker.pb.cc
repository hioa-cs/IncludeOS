// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: poker.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "poker.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace proto {

namespace {

const ::google::protobuf::Descriptor* PokerMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PokerMessage_reflection_ = NULL;
struct PokerMessageOneofInstance {
  const ::proto::Action* action_;
  const ::proto::GameState* gamestate_;
}* PokerMessage_default_oneof_instance_ = NULL;
const ::google::protobuf::Descriptor* Action_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Action_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Action_ActionType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Card_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Card_reflection_ = NULL;
const ::google::protobuf::Descriptor* Player_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Player_reflection_ = NULL;
const ::google::protobuf::Descriptor* GameState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GameState_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* MessageType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Rank_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Suite_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_poker_2eproto() {
  protobuf_AddDesc_poker_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "poker.proto");
  GOOGLE_CHECK(file != NULL);
  PokerMessage_descriptor_ = file->message_type(0);
  static const int PokerMessage_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PokerMessage, type_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(PokerMessage_default_oneof_instance_, action_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(PokerMessage_default_oneof_instance_, gamestate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PokerMessage, byte_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PokerMessage, content_),
  };
  PokerMessage_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PokerMessage_descriptor_,
      PokerMessage::default_instance_,
      PokerMessage_offsets_,
      -1,
      -1,
      -1,
      PokerMessage_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PokerMessage, _oneof_case_[0]),
      sizeof(PokerMessage),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PokerMessage, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PokerMessage, _is_default_instance_));
  Action_descriptor_ = file->message_type(1);
  static const int Action_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Action, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Action, bet_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Action, table_id_),
  };
  Action_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Action_descriptor_,
      Action::default_instance_,
      Action_offsets_,
      -1,
      -1,
      -1,
      sizeof(Action),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Action, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Action, _is_default_instance_));
  Action_ActionType_descriptor_ = Action_descriptor_->enum_type(0);
  Card_descriptor_ = file->message_type(2);
  static const int Card_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Card, suite_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Card, rank_),
  };
  Card_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Card_descriptor_,
      Card::default_instance_,
      Card_offsets_,
      -1,
      -1,
      -1,
      sizeof(Card),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Card, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Card, _is_default_instance_));
  Player_descriptor_ = file->message_type(3);
  static const int Player_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Player, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Player, stack_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Player, latest_action_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Player, hand_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Player, name_),
  };
  Player_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Player_descriptor_,
      Player::default_instance_,
      Player_offsets_,
      -1,
      -1,
      -1,
      sizeof(Player),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Player, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Player, _is_default_instance_));
  GameState_descriptor_ = file->message_type(4);
  static const int GameState_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, players_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, smallblind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, bigblind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, minimum_bet_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, pot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, button_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, me_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, whos_turn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, table_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, community_cards_),
  };
  GameState_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GameState_descriptor_,
      GameState::default_instance_,
      GameState_offsets_,
      -1,
      -1,
      -1,
      sizeof(GameState),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GameState, _is_default_instance_));
  MessageType_descriptor_ = file->enum_type(0);
  Rank_descriptor_ = file->enum_type(1);
  Suite_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_poker_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PokerMessage_descriptor_, &PokerMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Action_descriptor_, &Action::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Card_descriptor_, &Card::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Player_descriptor_, &Player::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GameState_descriptor_, &GameState::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_poker_2eproto() {
  delete PokerMessage::default_instance_;
  delete PokerMessage_default_oneof_instance_;
  delete PokerMessage_reflection_;
  delete Action::default_instance_;
  delete Action_reflection_;
  delete Card::default_instance_;
  delete Card_reflection_;
  delete Player::default_instance_;
  delete Player_reflection_;
  delete GameState::default_instance_;
  delete GameState_reflection_;
}

void protobuf_AddDesc_poker_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013poker.proto\022\005proto\"\226\001\n\014PokerMessage\022 \n"
    "\004type\030\001 \001(\0162\022.proto.MessageType\022\037\n\006actio"
    "n\030\002 \001(\0132\r.proto.ActionH\000\022%\n\tgamestate\030\003 "
    "\001(\0132\020.proto.GameStateH\000\022\021\n\tbyte_size\030\005 \001"
    "(\005B\t\n\007content\"\234\001\n\006Action\022&\n\004type\030\001 \001(\0162\030"
    ".proto.Action.ActionType\022\013\n\003bet\030\002 \001(\005\022\020\n"
    "\010table_id\030\003 \001(\005\"K\n\nActionType\022\010\n\004NONE\020\000\022"
    "\010\n\004FOLD\020\001\022\t\n\005CHECK\020\002\022\010\n\004CALL\020\003\022\t\n\005RAISE\020"
    "\004\022\t\n\005ALLIN\020\005\">\n\004Card\022\033\n\005suite\030\001 \001(\0162\014.pr"
    "oto.Suite\022\031\n\004rank\030\002 \001(\0162\013.proto.Rank\"e\n\006"
    "Player\022\n\n\002id\030\001 \001(\005\022\r\n\005stack\030\002 \001(\005\022$\n\rlat"
    "est_action\030\003 \001(\0132\r.proto.Action\022\014\n\004hand\030"
    "\005 \001(\004\022\014\n\004name\030\006 \001(\t\"\332\001\n\tGameState\022\036\n\007pla"
    "yers\030\001 \003(\0132\r.proto.Player\022\022\n\nsmallblind\030"
    "\002 \001(\005\022\020\n\010bigblind\030\003 \001(\005\022\023\n\013minimum_bet\030\004"
    " \001(\005\022\013\n\003pot\030\005 \001(\005\022\016\n\006button\030\006 \001(\005\022\n\n\002me\030"
    "\007 \001(\005\022\021\n\twhos_turn\030\010 \001(\005\022\020\n\010table_id\030\t \001"
    "(\005\022$\n\017community_cards\030\n \003(\0132\013.proto.Card"
    "*<\n\013MessageType\022\n\n\006ACTION\020\000\022\026\n\022REQUEST_G"
    "AME_STATE\020\001\022\t\n\005LOGIN\020\002*\234\001\n\004Rank\022\014\n\010BACKS"
    "IDE\020\000\022\007\n\003ONE\020\001\022\007\n\003TWO\020\002\022\t\n\005THREE\020\003\022\010\n\004FO"
    "UR\020\004\022\010\n\004FIVE\020\005\022\007\n\003SIX\020\006\022\t\n\005SEVEN\020\007\022\t\n\005EI"
    "GHT\020\010\022\010\n\004NINE\020\t\022\005\n\001T\020\n\022\005\n\001J\020\013\022\005\n\001Q\020\014\022\005\n\001"
    "K\020\r\022\005\n\001A\020\016\022\t\n\005JOKER\020\017*8\n\005Suite\022\n\n\006SPADES"
    "\020\000\022\n\n\006HEARTS\020\001\022\014\n\010DIAMONDS\020\002\022\t\n\005CLUBS\020\003b"
    "\006proto3", 1007);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "poker.proto", &protobuf_RegisterTypes);
  PokerMessage::default_instance_ = new PokerMessage();
  PokerMessage_default_oneof_instance_ = new PokerMessageOneofInstance();
  Action::default_instance_ = new Action();
  Card::default_instance_ = new Card();
  Player::default_instance_ = new Player();
  GameState::default_instance_ = new GameState();
  PokerMessage::default_instance_->InitAsDefaultInstance();
  Action::default_instance_->InitAsDefaultInstance();
  Card::default_instance_->InitAsDefaultInstance();
  Player::default_instance_->InitAsDefaultInstance();
  GameState::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_poker_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_poker_2eproto {
  StaticDescriptorInitializer_poker_2eproto() {
    protobuf_AddDesc_poker_2eproto();
  }
} static_descriptor_initializer_poker_2eproto_;
const ::google::protobuf::EnumDescriptor* MessageType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MessageType_descriptor_;
}
bool MessageType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Rank_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Rank_descriptor_;
}
bool Rank_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Suite_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Suite_descriptor_;
}
bool Suite_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#ifndef _MSC_VER
const int PokerMessage::kTypeFieldNumber;
const int PokerMessage::kActionFieldNumber;
const int PokerMessage::kGamestateFieldNumber;
const int PokerMessage::kByteSizeFieldNumber;
#endif  // !_MSC_VER

PokerMessage::PokerMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.PokerMessage)
}

void PokerMessage::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  PokerMessage_default_oneof_instance_->action_ = const_cast< ::proto::Action*>(&::proto::Action::default_instance());
  PokerMessage_default_oneof_instance_->gamestate_ = const_cast< ::proto::GameState*>(&::proto::GameState::default_instance());
}

PokerMessage::PokerMessage(const PokerMessage& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:proto.PokerMessage)
}

void PokerMessage::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  type_ = 0;
  byte_size_ = 0;
  clear_has_content();
}

PokerMessage::~PokerMessage() {
  // @@protoc_insertion_point(destructor:proto.PokerMessage)
  SharedDtor();
}

void PokerMessage::SharedDtor() {
  if (has_content()) {
    clear_content();
  }
  if (this != default_instance_) {
  }
}

void PokerMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PokerMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PokerMessage_descriptor_;
}

const PokerMessage& PokerMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_poker_2eproto();
  return *default_instance_;
}

PokerMessage* PokerMessage::default_instance_ = NULL;

PokerMessage* PokerMessage::New(::google::protobuf::Arena* arena) const {
  PokerMessage* n = new PokerMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PokerMessage::clear_content() {
  switch(content_case()) {
    case kAction: {
      delete content_.action_;
      break;
    }
    case kGamestate: {
      delete content_.gamestate_;
      break;
    }
    case CONTENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = CONTENT_NOT_SET;
}


void PokerMessage::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<PokerMessage*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(type_, byte_size_);

#undef ZR_HELPER_
#undef ZR_

  clear_content();
}

bool PokerMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.PokerMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.MessageType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::proto::MessageType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_action;
        break;
      }

      // optional .proto.Action action = 2;
      case 2: {
        if (tag == 18) {
         parse_action:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_action()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_gamestate;
        break;
      }

      // optional .proto.GameState gamestate = 3;
      case 3: {
        if (tag == 26) {
         parse_gamestate:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gamestate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_byte_size;
        break;
      }

      // optional int32 byte_size = 5;
      case 5: {
        if (tag == 40) {
         parse_byte_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &byte_size_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.PokerMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.PokerMessage)
  return false;
#undef DO_
}

void PokerMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.PokerMessage)
  // optional .proto.MessageType type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .proto.Action action = 2;
  if (has_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *content_.action_, output);
  }

  // optional .proto.GameState gamestate = 3;
  if (has_gamestate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *content_.gamestate_, output);
  }

  // optional int32 byte_size = 5;
  if (this->byte_size() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->byte_size(), output);
  }

  // @@protoc_insertion_point(serialize_end:proto.PokerMessage)
}

::google::protobuf::uint8* PokerMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.PokerMessage)
  // optional .proto.MessageType type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .proto.Action action = 2;
  if (has_action()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *content_.action_, target);
  }

  // optional .proto.GameState gamestate = 3;
  if (has_gamestate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *content_.gamestate_, target);
  }

  // optional int32 byte_size = 5;
  if (this->byte_size() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->byte_size(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:proto.PokerMessage)
  return target;
}

int PokerMessage::ByteSize() const {
  int total_size = 0;

  // optional .proto.MessageType type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // optional int32 byte_size = 5;
  if (this->byte_size() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->byte_size());
  }

  switch (content_case()) {
    // optional .proto.Action action = 2;
    case kAction: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *content_.action_);
      break;
    }
    // optional .proto.GameState gamestate = 3;
    case kGamestate: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *content_.gamestate_);
      break;
    }
    case CONTENT_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PokerMessage::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const PokerMessage* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PokerMessage>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PokerMessage::MergeFrom(const PokerMessage& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  switch (from.content_case()) {
    case kAction: {
      mutable_action()->::proto::Action::MergeFrom(from.action());
      break;
    }
    case kGamestate: {
      mutable_gamestate()->::proto::GameState::MergeFrom(from.gamestate());
      break;
    }
    case CONTENT_NOT_SET: {
      break;
    }
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.byte_size() != 0) {
    set_byte_size(from.byte_size());
  }
}

void PokerMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PokerMessage::CopyFrom(const PokerMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PokerMessage::IsInitialized() const {

  return true;
}

void PokerMessage::Swap(PokerMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PokerMessage::InternalSwap(PokerMessage* other) {
  std::swap(type_, other->type_);
  std::swap(byte_size_, other->byte_size_);
  std::swap(content_, other->content_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PokerMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PokerMessage_descriptor_;
  metadata.reflection = PokerMessage_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PokerMessage

// optional .proto.MessageType type = 1;
void PokerMessage::clear_type() {
  type_ = 0;
}
 ::proto::MessageType PokerMessage::type() const {
  // @@protoc_insertion_point(field_get:proto.PokerMessage.type)
  return static_cast< ::proto::MessageType >(type_);
}
 void PokerMessage::set_type(::proto::MessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.PokerMessage.type)
}

// optional .proto.Action action = 2;
bool PokerMessage::has_action() const {
  return content_case() == kAction;
}
void PokerMessage::set_has_action() {
  _oneof_case_[0] = kAction;
}
void PokerMessage::clear_action() {
  if (has_action()) {
    delete content_.action_;
    clear_has_content();
  }
}
 const ::proto::Action& PokerMessage::action() const {
  // @@protoc_insertion_point(field_get:proto.PokerMessage.action)
  return has_action()
      ? *content_.action_
      : ::proto::Action::default_instance();
}
::proto::Action* PokerMessage::mutable_action() {
  if (!has_action()) {
    clear_content();
    set_has_action();
    content_.action_ = new ::proto::Action;
  }
  // @@protoc_insertion_point(field_mutable:proto.PokerMessage.action)
  return content_.action_;
}
::proto::Action* PokerMessage::release_action() {
  if (has_action()) {
    clear_has_content();
    ::proto::Action* temp = content_.action_;
    content_.action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void PokerMessage::set_allocated_action(::proto::Action* action) {
  clear_content();
  if (action) {
    set_has_action();
    content_.action_ = action;
  }
  // @@protoc_insertion_point(field_set_allocated:proto.PokerMessage.action)
}

// optional .proto.GameState gamestate = 3;
bool PokerMessage::has_gamestate() const {
  return content_case() == kGamestate;
}
void PokerMessage::set_has_gamestate() {
  _oneof_case_[0] = kGamestate;
}
void PokerMessage::clear_gamestate() {
  if (has_gamestate()) {
    delete content_.gamestate_;
    clear_has_content();
  }
}
 const ::proto::GameState& PokerMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:proto.PokerMessage.gamestate)
  return has_gamestate()
      ? *content_.gamestate_
      : ::proto::GameState::default_instance();
}
::proto::GameState* PokerMessage::mutable_gamestate() {
  if (!has_gamestate()) {
    clear_content();
    set_has_gamestate();
    content_.gamestate_ = new ::proto::GameState;
  }
  // @@protoc_insertion_point(field_mutable:proto.PokerMessage.gamestate)
  return content_.gamestate_;
}
::proto::GameState* PokerMessage::release_gamestate() {
  if (has_gamestate()) {
    clear_has_content();
    ::proto::GameState* temp = content_.gamestate_;
    content_.gamestate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void PokerMessage::set_allocated_gamestate(::proto::GameState* gamestate) {
  clear_content();
  if (gamestate) {
    set_has_gamestate();
    content_.gamestate_ = gamestate;
  }
  // @@protoc_insertion_point(field_set_allocated:proto.PokerMessage.gamestate)
}

// optional int32 byte_size = 5;
void PokerMessage::clear_byte_size() {
  byte_size_ = 0;
}
 ::google::protobuf::int32 PokerMessage::byte_size() const {
  // @@protoc_insertion_point(field_get:proto.PokerMessage.byte_size)
  return byte_size_;
}
 void PokerMessage::set_byte_size(::google::protobuf::int32 value) {
  
  byte_size_ = value;
  // @@protoc_insertion_point(field_set:proto.PokerMessage.byte_size)
}

bool PokerMessage::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
void PokerMessage::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
PokerMessage::ContentCase PokerMessage::content_case() const {
  return PokerMessage::ContentCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Action_ActionType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Action_ActionType_descriptor_;
}
bool Action_ActionType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Action_ActionType Action::NONE;
const Action_ActionType Action::FOLD;
const Action_ActionType Action::CHECK;
const Action_ActionType Action::CALL;
const Action_ActionType Action::RAISE;
const Action_ActionType Action::ALLIN;
const Action_ActionType Action::ActionType_MIN;
const Action_ActionType Action::ActionType_MAX;
const int Action::ActionType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Action::kTypeFieldNumber;
const int Action::kBetFieldNumber;
const int Action::kTableIdFieldNumber;
#endif  // !_MSC_VER

Action::Action()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.Action)
}

void Action::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Action::Action(const Action& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:proto.Action)
}

void Action::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  type_ = 0;
  bet_ = 0;
  table_id_ = 0;
}

Action::~Action() {
  // @@protoc_insertion_point(destructor:proto.Action)
  SharedDtor();
}

void Action::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Action::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Action::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Action_descriptor_;
}

const Action& Action::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_poker_2eproto();
  return *default_instance_;
}

Action* Action::default_instance_ = NULL;

Action* Action::New(::google::protobuf::Arena* arena) const {
  Action* n = new Action;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Action::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Action*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(type_, table_id_);

#undef ZR_HELPER_
#undef ZR_

}

bool Action::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.Action)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.Action.ActionType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::proto::Action_ActionType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_bet;
        break;
      }

      // optional int32 bet = 2;
      case 2: {
        if (tag == 16) {
         parse_bet:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bet_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_table_id;
        break;
      }

      // optional int32 table_id = 3;
      case 3: {
        if (tag == 24) {
         parse_table_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &table_id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.Action)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.Action)
  return false;
#undef DO_
}

void Action::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.Action)
  // optional .proto.Action.ActionType type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional int32 bet = 2;
  if (this->bet() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->bet(), output);
  }

  // optional int32 table_id = 3;
  if (this->table_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->table_id(), output);
  }

  // @@protoc_insertion_point(serialize_end:proto.Action)
}

::google::protobuf::uint8* Action::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.Action)
  // optional .proto.Action.ActionType type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional int32 bet = 2;
  if (this->bet() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->bet(), target);
  }

  // optional int32 table_id = 3;
  if (this->table_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->table_id(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:proto.Action)
  return target;
}

int Action::ByteSize() const {
  int total_size = 0;

  // optional .proto.Action.ActionType type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // optional int32 bet = 2;
  if (this->bet() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->bet());
  }

  // optional int32 table_id = 3;
  if (this->table_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->table_id());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Action::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Action* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Action>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Action::MergeFrom(const Action& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.bet() != 0) {
    set_bet(from.bet());
  }
  if (from.table_id() != 0) {
    set_table_id(from.table_id());
  }
}

void Action::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Action::CopyFrom(const Action& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Action::IsInitialized() const {

  return true;
}

void Action::Swap(Action* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Action::InternalSwap(Action* other) {
  std::swap(type_, other->type_);
  std::swap(bet_, other->bet_);
  std::swap(table_id_, other->table_id_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Action::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Action_descriptor_;
  metadata.reflection = Action_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Action

// optional .proto.Action.ActionType type = 1;
void Action::clear_type() {
  type_ = 0;
}
 ::proto::Action_ActionType Action::type() const {
  // @@protoc_insertion_point(field_get:proto.Action.type)
  return static_cast< ::proto::Action_ActionType >(type_);
}
 void Action::set_type(::proto::Action_ActionType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.Action.type)
}

// optional int32 bet = 2;
void Action::clear_bet() {
  bet_ = 0;
}
 ::google::protobuf::int32 Action::bet() const {
  // @@protoc_insertion_point(field_get:proto.Action.bet)
  return bet_;
}
 void Action::set_bet(::google::protobuf::int32 value) {
  
  bet_ = value;
  // @@protoc_insertion_point(field_set:proto.Action.bet)
}

// optional int32 table_id = 3;
void Action::clear_table_id() {
  table_id_ = 0;
}
 ::google::protobuf::int32 Action::table_id() const {
  // @@protoc_insertion_point(field_get:proto.Action.table_id)
  return table_id_;
}
 void Action::set_table_id(::google::protobuf::int32 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:proto.Action.table_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int Card::kSuiteFieldNumber;
const int Card::kRankFieldNumber;
#endif  // !_MSC_VER

Card::Card()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.Card)
}

void Card::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Card::Card(const Card& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:proto.Card)
}

void Card::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  suite_ = 0;
  rank_ = 0;
}

Card::~Card() {
  // @@protoc_insertion_point(destructor:proto.Card)
  SharedDtor();
}

void Card::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Card::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Card::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Card_descriptor_;
}

const Card& Card::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_poker_2eproto();
  return *default_instance_;
}

Card* Card::default_instance_ = NULL;

Card* Card::New(::google::protobuf::Arena* arena) const {
  Card* n = new Card;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Card::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Card*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(suite_, rank_);

#undef ZR_HELPER_
#undef ZR_

}

bool Card::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.Card)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .proto.Suite suite = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_suite(static_cast< ::proto::Suite >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_rank;
        break;
      }

      // optional .proto.Rank rank = 2;
      case 2: {
        if (tag == 16) {
         parse_rank:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_rank(static_cast< ::proto::Rank >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.Card)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.Card)
  return false;
#undef DO_
}

void Card::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.Card)
  // optional .proto.Suite suite = 1;
  if (this->suite() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->suite(), output);
  }

  // optional .proto.Rank rank = 2;
  if (this->rank() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->rank(), output);
  }

  // @@protoc_insertion_point(serialize_end:proto.Card)
}

::google::protobuf::uint8* Card::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.Card)
  // optional .proto.Suite suite = 1;
  if (this->suite() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->suite(), target);
  }

  // optional .proto.Rank rank = 2;
  if (this->rank() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->rank(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:proto.Card)
  return target;
}

int Card::ByteSize() const {
  int total_size = 0;

  // optional .proto.Suite suite = 1;
  if (this->suite() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->suite());
  }

  // optional .proto.Rank rank = 2;
  if (this->rank() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->rank());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Card::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Card* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Card>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Card::MergeFrom(const Card& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from.suite() != 0) {
    set_suite(from.suite());
  }
  if (from.rank() != 0) {
    set_rank(from.rank());
  }
}

void Card::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Card::CopyFrom(const Card& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Card::IsInitialized() const {

  return true;
}

void Card::Swap(Card* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Card::InternalSwap(Card* other) {
  std::swap(suite_, other->suite_);
  std::swap(rank_, other->rank_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Card::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Card_descriptor_;
  metadata.reflection = Card_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Card

// optional .proto.Suite suite = 1;
void Card::clear_suite() {
  suite_ = 0;
}
 ::proto::Suite Card::suite() const {
  // @@protoc_insertion_point(field_get:proto.Card.suite)
  return static_cast< ::proto::Suite >(suite_);
}
 void Card::set_suite(::proto::Suite value) {
  
  suite_ = value;
  // @@protoc_insertion_point(field_set:proto.Card.suite)
}

// optional .proto.Rank rank = 2;
void Card::clear_rank() {
  rank_ = 0;
}
 ::proto::Rank Card::rank() const {
  // @@protoc_insertion_point(field_get:proto.Card.rank)
  return static_cast< ::proto::Rank >(rank_);
}
 void Card::set_rank(::proto::Rank value) {
  
  rank_ = value;
  // @@protoc_insertion_point(field_set:proto.Card.rank)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int Player::kIdFieldNumber;
const int Player::kStackFieldNumber;
const int Player::kLatestActionFieldNumber;
const int Player::kHandFieldNumber;
const int Player::kNameFieldNumber;
#endif  // !_MSC_VER

Player::Player()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.Player)
}

void Player::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  latest_action_ = const_cast< ::proto::Action*>(&::proto::Action::default_instance());
}

Player::Player(const Player& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:proto.Player)
}

void Player::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = 0;
  stack_ = 0;
  latest_action_ = NULL;
  hand_ = GOOGLE_ULONGLONG(0);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Player::~Player() {
  // @@protoc_insertion_point(destructor:proto.Player)
  SharedDtor();
}

void Player::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete latest_action_;
  }
}

void Player::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Player::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Player_descriptor_;
}

const Player& Player::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_poker_2eproto();
  return *default_instance_;
}

Player* Player::default_instance_ = NULL;

Player* Player::New(::google::protobuf::Arena* arena) const {
  Player* n = new Player;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Player::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Player*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(id_, stack_);
  if (GetArenaNoVirtual() == NULL && latest_action_ != NULL) delete latest_action_;
  latest_action_ = NULL;
  hand_ = GOOGLE_ULONGLONG(0);
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

}

bool Player::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.Player)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_stack;
        break;
      }

      // optional int32 stack = 2;
      case 2: {
        if (tag == 16) {
         parse_stack:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &stack_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_latest_action;
        break;
      }

      // optional .proto.Action latest_action = 3;
      case 3: {
        if (tag == 26) {
         parse_latest_action:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_latest_action()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_hand;
        break;
      }

      // optional uint64 hand = 5;
      case 5: {
        if (tag == 40) {
         parse_hand:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &hand_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_name;
        break;
      }

      // optional string name = 6;
      case 6: {
        if (tag == 50) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "proto.Player.name"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.Player)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.Player)
  return false;
#undef DO_
}

void Player::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.Player)
  // optional int32 id = 1;
  if (this->id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 stack = 2;
  if (this->stack() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->stack(), output);
  }

  // optional .proto.Action latest_action = 3;
  if (this->has_latest_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->latest_action_, output);
  }

  // optional uint64 hand = 5;
  if (this->hand() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->hand(), output);
  }

  // optional string name = 6;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "proto.Player.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->name(), output);
  }

  // @@protoc_insertion_point(serialize_end:proto.Player)
}

::google::protobuf::uint8* Player::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.Player)
  // optional int32 id = 1;
  if (this->id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional int32 stack = 2;
  if (this->stack() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->stack(), target);
  }

  // optional .proto.Action latest_action = 3;
  if (this->has_latest_action()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->latest_action_, target);
  }

  // optional uint64 hand = 5;
  if (this->hand() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->hand(), target);
  }

  // optional string name = 6;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "proto.Player.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->name(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:proto.Player)
  return target;
}

int Player::ByteSize() const {
  int total_size = 0;

  // optional int32 id = 1;
  if (this->id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  // optional int32 stack = 2;
  if (this->stack() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->stack());
  }

  // optional .proto.Action latest_action = 3;
  if (this->has_latest_action()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->latest_action_);
  }

  // optional uint64 hand = 5;
  if (this->hand() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->hand());
  }

  // optional string name = 6;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Player::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Player* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Player>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Player::MergeFrom(const Player& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from.id() != 0) {
    set_id(from.id());
  }
  if (from.stack() != 0) {
    set_stack(from.stack());
  }
  if (from.has_latest_action()) {
    mutable_latest_action()->::proto::Action::MergeFrom(from.latest_action());
  }
  if (from.hand() != 0) {
    set_hand(from.hand());
  }
  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
}

void Player::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Player::CopyFrom(const Player& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Player::IsInitialized() const {

  return true;
}

void Player::Swap(Player* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Player::InternalSwap(Player* other) {
  std::swap(id_, other->id_);
  std::swap(stack_, other->stack_);
  std::swap(latest_action_, other->latest_action_);
  std::swap(hand_, other->hand_);
  name_.Swap(&other->name_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Player::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Player_descriptor_;
  metadata.reflection = Player_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Player

// optional int32 id = 1;
void Player::clear_id() {
  id_ = 0;
}
 ::google::protobuf::int32 Player::id() const {
  // @@protoc_insertion_point(field_get:proto.Player.id)
  return id_;
}
 void Player::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:proto.Player.id)
}

// optional int32 stack = 2;
void Player::clear_stack() {
  stack_ = 0;
}
 ::google::protobuf::int32 Player::stack() const {
  // @@protoc_insertion_point(field_get:proto.Player.stack)
  return stack_;
}
 void Player::set_stack(::google::protobuf::int32 value) {
  
  stack_ = value;
  // @@protoc_insertion_point(field_set:proto.Player.stack)
}

// optional .proto.Action latest_action = 3;
bool Player::has_latest_action() const {
  return !_is_default_instance_ && latest_action_ != NULL;
}
void Player::clear_latest_action() {
  if (GetArenaNoVirtual() == NULL && latest_action_ != NULL) delete latest_action_;
  latest_action_ = NULL;
}
const ::proto::Action& Player::latest_action() const {
  // @@protoc_insertion_point(field_get:proto.Player.latest_action)
  return latest_action_ != NULL ? *latest_action_ : *default_instance_->latest_action_;
}
::proto::Action* Player::mutable_latest_action() {
  
  if (latest_action_ == NULL) {
    latest_action_ = new ::proto::Action;
  }
  // @@protoc_insertion_point(field_mutable:proto.Player.latest_action)
  return latest_action_;
}
::proto::Action* Player::release_latest_action() {
  
  ::proto::Action* temp = latest_action_;
  latest_action_ = NULL;
  return temp;
}
void Player::set_allocated_latest_action(::proto::Action* latest_action) {
  delete latest_action_;
  latest_action_ = latest_action;
  if (latest_action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Player.latest_action)
}

// optional uint64 hand = 5;
void Player::clear_hand() {
  hand_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 Player::hand() const {
  // @@protoc_insertion_point(field_get:proto.Player.hand)
  return hand_;
}
 void Player::set_hand(::google::protobuf::uint64 value) {
  
  hand_ = value;
  // @@protoc_insertion_point(field_set:proto.Player.hand)
}

// optional string name = 6;
void Player::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:proto.Player.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Player::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Player.name)
}
 void Player::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Player.name)
}
 void Player::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Player.name)
}
 ::std::string* Player::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.Player.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Player::release_name() {
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Player::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.Player.name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int GameState::kPlayersFieldNumber;
const int GameState::kSmallblindFieldNumber;
const int GameState::kBigblindFieldNumber;
const int GameState::kMinimumBetFieldNumber;
const int GameState::kPotFieldNumber;
const int GameState::kButtonFieldNumber;
const int GameState::kMeFieldNumber;
const int GameState::kWhosTurnFieldNumber;
const int GameState::kTableIdFieldNumber;
const int GameState::kCommunityCardsFieldNumber;
#endif  // !_MSC_VER

GameState::GameState()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:proto.GameState)
}

void GameState::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

GameState::GameState(const GameState& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:proto.GameState)
}

void GameState::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  smallblind_ = 0;
  bigblind_ = 0;
  minimum_bet_ = 0;
  pot_ = 0;
  button_ = 0;
  me_ = 0;
  whos_turn_ = 0;
  table_id_ = 0;
}

GameState::~GameState() {
  // @@protoc_insertion_point(destructor:proto.GameState)
  SharedDtor();
}

void GameState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GameState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GameState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GameState_descriptor_;
}

const GameState& GameState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_poker_2eproto();
  return *default_instance_;
}

GameState* GameState::default_instance_ = NULL;

GameState* GameState::New(::google::protobuf::Arena* arena) const {
  GameState* n = new GameState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GameState::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<GameState*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(smallblind_, whos_turn_);
  table_id_ = 0;

#undef ZR_HELPER_
#undef ZR_

  players_.Clear();
  community_cards_.Clear();
}

bool GameState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:proto.GameState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .proto.Player players = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_players:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_players()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_players;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(16)) goto parse_smallblind;
        break;
      }

      // optional int32 smallblind = 2;
      case 2: {
        if (tag == 16) {
         parse_smallblind:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &smallblind_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_bigblind;
        break;
      }

      // optional int32 bigblind = 3;
      case 3: {
        if (tag == 24) {
         parse_bigblind:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bigblind_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_minimum_bet;
        break;
      }

      // optional int32 minimum_bet = 4;
      case 4: {
        if (tag == 32) {
         parse_minimum_bet:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &minimum_bet_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_pot;
        break;
      }

      // optional int32 pot = 5;
      case 5: {
        if (tag == 40) {
         parse_pot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pot_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_button;
        break;
      }

      // optional int32 button = 6;
      case 6: {
        if (tag == 48) {
         parse_button:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &button_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_me;
        break;
      }

      // optional int32 me = 7;
      case 7: {
        if (tag == 56) {
         parse_me:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &me_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_whos_turn;
        break;
      }

      // optional int32 whos_turn = 8;
      case 8: {
        if (tag == 64) {
         parse_whos_turn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &whos_turn_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_table_id;
        break;
      }

      // optional int32 table_id = 9;
      case 9: {
        if (tag == 72) {
         parse_table_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &table_id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_community_cards;
        break;
      }

      // repeated .proto.Card community_cards = 10;
      case 10: {
        if (tag == 82) {
         parse_community_cards:
          DO_(input->IncrementRecursionDepth());
         parse_loop_community_cards:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_community_cards()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_loop_community_cards;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:proto.GameState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:proto.GameState)
  return false;
#undef DO_
}

void GameState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:proto.GameState)
  // repeated .proto.Player players = 1;
  for (unsigned int i = 0, n = this->players_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->players(i), output);
  }

  // optional int32 smallblind = 2;
  if (this->smallblind() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->smallblind(), output);
  }

  // optional int32 bigblind = 3;
  if (this->bigblind() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->bigblind(), output);
  }

  // optional int32 minimum_bet = 4;
  if (this->minimum_bet() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->minimum_bet(), output);
  }

  // optional int32 pot = 5;
  if (this->pot() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->pot(), output);
  }

  // optional int32 button = 6;
  if (this->button() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->button(), output);
  }

  // optional int32 me = 7;
  if (this->me() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->me(), output);
  }

  // optional int32 whos_turn = 8;
  if (this->whos_turn() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->whos_turn(), output);
  }

  // optional int32 table_id = 9;
  if (this->table_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->table_id(), output);
  }

  // repeated .proto.Card community_cards = 10;
  for (unsigned int i = 0, n = this->community_cards_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->community_cards(i), output);
  }

  // @@protoc_insertion_point(serialize_end:proto.GameState)
}

::google::protobuf::uint8* GameState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:proto.GameState)
  // repeated .proto.Player players = 1;
  for (unsigned int i = 0, n = this->players_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->players(i), target);
  }

  // optional int32 smallblind = 2;
  if (this->smallblind() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->smallblind(), target);
  }

  // optional int32 bigblind = 3;
  if (this->bigblind() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->bigblind(), target);
  }

  // optional int32 minimum_bet = 4;
  if (this->minimum_bet() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->minimum_bet(), target);
  }

  // optional int32 pot = 5;
  if (this->pot() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->pot(), target);
  }

  // optional int32 button = 6;
  if (this->button() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->button(), target);
  }

  // optional int32 me = 7;
  if (this->me() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->me(), target);
  }

  // optional int32 whos_turn = 8;
  if (this->whos_turn() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->whos_turn(), target);
  }

  // optional int32 table_id = 9;
  if (this->table_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->table_id(), target);
  }

  // repeated .proto.Card community_cards = 10;
  for (unsigned int i = 0, n = this->community_cards_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->community_cards(i), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:proto.GameState)
  return target;
}

int GameState::ByteSize() const {
  int total_size = 0;

  // optional int32 smallblind = 2;
  if (this->smallblind() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->smallblind());
  }

  // optional int32 bigblind = 3;
  if (this->bigblind() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->bigblind());
  }

  // optional int32 minimum_bet = 4;
  if (this->minimum_bet() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->minimum_bet());
  }

  // optional int32 pot = 5;
  if (this->pot() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->pot());
  }

  // optional int32 button = 6;
  if (this->button() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->button());
  }

  // optional int32 me = 7;
  if (this->me() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->me());
  }

  // optional int32 whos_turn = 8;
  if (this->whos_turn() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->whos_turn());
  }

  // optional int32 table_id = 9;
  if (this->table_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->table_id());
  }

  // repeated .proto.Player players = 1;
  total_size += 1 * this->players_size();
  for (int i = 0; i < this->players_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->players(i));
  }

  // repeated .proto.Card community_cards = 10;
  total_size += 1 * this->community_cards_size();
  for (int i = 0; i < this->community_cards_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->community_cards(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GameState::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const GameState* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GameState>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GameState::MergeFrom(const GameState& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  players_.MergeFrom(from.players_);
  community_cards_.MergeFrom(from.community_cards_);
  if (from.smallblind() != 0) {
    set_smallblind(from.smallblind());
  }
  if (from.bigblind() != 0) {
    set_bigblind(from.bigblind());
  }
  if (from.minimum_bet() != 0) {
    set_minimum_bet(from.minimum_bet());
  }
  if (from.pot() != 0) {
    set_pot(from.pot());
  }
  if (from.button() != 0) {
    set_button(from.button());
  }
  if (from.me() != 0) {
    set_me(from.me());
  }
  if (from.whos_turn() != 0) {
    set_whos_turn(from.whos_turn());
  }
  if (from.table_id() != 0) {
    set_table_id(from.table_id());
  }
}

void GameState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameState::CopyFrom(const GameState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameState::IsInitialized() const {

  return true;
}

void GameState::Swap(GameState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameState::InternalSwap(GameState* other) {
  players_.UnsafeArenaSwap(&other->players_);
  std::swap(smallblind_, other->smallblind_);
  std::swap(bigblind_, other->bigblind_);
  std::swap(minimum_bet_, other->minimum_bet_);
  std::swap(pot_, other->pot_);
  std::swap(button_, other->button_);
  std::swap(me_, other->me_);
  std::swap(whos_turn_, other->whos_turn_);
  std::swap(table_id_, other->table_id_);
  community_cards_.UnsafeArenaSwap(&other->community_cards_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GameState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GameState_descriptor_;
  metadata.reflection = GameState_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GameState

// repeated .proto.Player players = 1;
int GameState::players_size() const {
  return players_.size();
}
void GameState::clear_players() {
  players_.Clear();
}
const ::proto::Player& GameState::players(int index) const {
  // @@protoc_insertion_point(field_get:proto.GameState.players)
  return players_.Get(index);
}
::proto::Player* GameState::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:proto.GameState.players)
  return players_.Mutable(index);
}
::proto::Player* GameState::add_players() {
  // @@protoc_insertion_point(field_add:proto.GameState.players)
  return players_.Add();
}
::google::protobuf::RepeatedPtrField< ::proto::Player >*
GameState::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:proto.GameState.players)
  return &players_;
}
const ::google::protobuf::RepeatedPtrField< ::proto::Player >&
GameState::players() const {
  // @@protoc_insertion_point(field_list:proto.GameState.players)
  return players_;
}

// optional int32 smallblind = 2;
void GameState::clear_smallblind() {
  smallblind_ = 0;
}
 ::google::protobuf::int32 GameState::smallblind() const {
  // @@protoc_insertion_point(field_get:proto.GameState.smallblind)
  return smallblind_;
}
 void GameState::set_smallblind(::google::protobuf::int32 value) {
  
  smallblind_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.smallblind)
}

// optional int32 bigblind = 3;
void GameState::clear_bigblind() {
  bigblind_ = 0;
}
 ::google::protobuf::int32 GameState::bigblind() const {
  // @@protoc_insertion_point(field_get:proto.GameState.bigblind)
  return bigblind_;
}
 void GameState::set_bigblind(::google::protobuf::int32 value) {
  
  bigblind_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.bigblind)
}

// optional int32 minimum_bet = 4;
void GameState::clear_minimum_bet() {
  minimum_bet_ = 0;
}
 ::google::protobuf::int32 GameState::minimum_bet() const {
  // @@protoc_insertion_point(field_get:proto.GameState.minimum_bet)
  return minimum_bet_;
}
 void GameState::set_minimum_bet(::google::protobuf::int32 value) {
  
  minimum_bet_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.minimum_bet)
}

// optional int32 pot = 5;
void GameState::clear_pot() {
  pot_ = 0;
}
 ::google::protobuf::int32 GameState::pot() const {
  // @@protoc_insertion_point(field_get:proto.GameState.pot)
  return pot_;
}
 void GameState::set_pot(::google::protobuf::int32 value) {
  
  pot_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.pot)
}

// optional int32 button = 6;
void GameState::clear_button() {
  button_ = 0;
}
 ::google::protobuf::int32 GameState::button() const {
  // @@protoc_insertion_point(field_get:proto.GameState.button)
  return button_;
}
 void GameState::set_button(::google::protobuf::int32 value) {
  
  button_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.button)
}

// optional int32 me = 7;
void GameState::clear_me() {
  me_ = 0;
}
 ::google::protobuf::int32 GameState::me() const {
  // @@protoc_insertion_point(field_get:proto.GameState.me)
  return me_;
}
 void GameState::set_me(::google::protobuf::int32 value) {
  
  me_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.me)
}

// optional int32 whos_turn = 8;
void GameState::clear_whos_turn() {
  whos_turn_ = 0;
}
 ::google::protobuf::int32 GameState::whos_turn() const {
  // @@protoc_insertion_point(field_get:proto.GameState.whos_turn)
  return whos_turn_;
}
 void GameState::set_whos_turn(::google::protobuf::int32 value) {
  
  whos_turn_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.whos_turn)
}

// optional int32 table_id = 9;
void GameState::clear_table_id() {
  table_id_ = 0;
}
 ::google::protobuf::int32 GameState::table_id() const {
  // @@protoc_insertion_point(field_get:proto.GameState.table_id)
  return table_id_;
}
 void GameState::set_table_id(::google::protobuf::int32 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.table_id)
}

// repeated .proto.Card community_cards = 10;
int GameState::community_cards_size() const {
  return community_cards_.size();
}
void GameState::clear_community_cards() {
  community_cards_.Clear();
}
const ::proto::Card& GameState::community_cards(int index) const {
  // @@protoc_insertion_point(field_get:proto.GameState.community_cards)
  return community_cards_.Get(index);
}
::proto::Card* GameState::mutable_community_cards(int index) {
  // @@protoc_insertion_point(field_mutable:proto.GameState.community_cards)
  return community_cards_.Mutable(index);
}
::proto::Card* GameState::add_community_cards() {
  // @@protoc_insertion_point(field_add:proto.GameState.community_cards)
  return community_cards_.Add();
}
::google::protobuf::RepeatedPtrField< ::proto::Card >*
GameState::mutable_community_cards() {
  // @@protoc_insertion_point(field_mutable_list:proto.GameState.community_cards)
  return &community_cards_;
}
const ::google::protobuf::RepeatedPtrField< ::proto::Card >&
GameState::community_cards() const {
  // @@protoc_insertion_point(field_list:proto.GameState.community_cards)
  return community_cards_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

// @@protoc_insertion_point(global_scope)
