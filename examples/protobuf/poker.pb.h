// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: poker.proto

#ifndef PROTOBUF_poker_2eproto__INCLUDED
#define PROTOBUF_poker_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_poker_2eproto();
void protobuf_AssignDesc_poker_2eproto();
void protobuf_ShutdownFile_poker_2eproto();

class Action;
class Card;
class GameState;
class Player;
class PokerMessage;

enum Action_ActionType {
  Action_ActionType_NONE = 0,
  Action_ActionType_FOLD = 1,
  Action_ActionType_CHECK = 2,
  Action_ActionType_CALL = 3,
  Action_ActionType_RAISE = 4,
  Action_ActionType_ALLIN = 5,
  Action_ActionType_Action_ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Action_ActionType_Action_ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Action_ActionType_IsValid(int value);
const Action_ActionType Action_ActionType_ActionType_MIN = Action_ActionType_NONE;
const Action_ActionType Action_ActionType_ActionType_MAX = Action_ActionType_ALLIN;
const int Action_ActionType_ActionType_ARRAYSIZE = Action_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Action_ActionType_descriptor();
inline const ::std::string& Action_ActionType_Name(Action_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Action_ActionType_descriptor(), value);
}
inline bool Action_ActionType_Parse(
    const ::std::string& name, Action_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Action_ActionType>(
    Action_ActionType_descriptor(), name, value);
}
enum MessageType {
  ACTION = 0,
  REQUEST_GAME_STATE = 1,
  LOGIN = 2,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = ACTION;
const MessageType MessageType_MAX = LOGIN;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum Rank {
  BACKSIDE = 0,
  ONE = 1,
  TWO = 2,
  THREE = 3,
  FOUR = 4,
  FIVE = 5,
  SIX = 6,
  SEVEN = 7,
  EIGHT = 8,
  NINE = 9,
  T = 10,
  J = 11,
  Q = 12,
  K = 13,
  A = 14,
  JOKER = 15,
  Rank_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Rank_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Rank_IsValid(int value);
const Rank Rank_MIN = BACKSIDE;
const Rank Rank_MAX = JOKER;
const int Rank_ARRAYSIZE = Rank_MAX + 1;

const ::google::protobuf::EnumDescriptor* Rank_descriptor();
inline const ::std::string& Rank_Name(Rank value) {
  return ::google::protobuf::internal::NameOfEnum(
    Rank_descriptor(), value);
}
inline bool Rank_Parse(
    const ::std::string& name, Rank* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Rank>(
    Rank_descriptor(), name, value);
}
enum Suite {
  SPADES = 0,
  HEARTS = 1,
  DIAMONDS = 2,
  CLUBS = 3,
  Suite_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Suite_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Suite_IsValid(int value);
const Suite Suite_MIN = SPADES;
const Suite Suite_MAX = CLUBS;
const int Suite_ARRAYSIZE = Suite_MAX + 1;

const ::google::protobuf::EnumDescriptor* Suite_descriptor();
inline const ::std::string& Suite_Name(Suite value) {
  return ::google::protobuf::internal::NameOfEnum(
    Suite_descriptor(), value);
}
inline bool Suite_Parse(
    const ::std::string& name, Suite* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Suite>(
    Suite_descriptor(), name, value);
}
// ===================================================================

class PokerMessage : public ::google::protobuf::Message {
 public:
  PokerMessage();
  virtual ~PokerMessage();

  PokerMessage(const PokerMessage& from);

  inline PokerMessage& operator=(const PokerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PokerMessage& default_instance();

  enum ContentCase {
    kAction = 2,
    kGamestate = 3,
    CONTENT_NOT_SET = 0,
  };

  void Swap(PokerMessage* other);

  // implements Message ----------------------------------------------

  inline PokerMessage* New() const { return New(NULL); }

  PokerMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PokerMessage& from);
  void MergeFrom(const PokerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PokerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.MessageType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::proto::MessageType type() const;
  void set_type(::proto::MessageType value);

  // optional .proto.Action action = 2;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 2;
  const ::proto::Action& action() const;
  ::proto::Action* mutable_action();
  ::proto::Action* release_action();
  void set_allocated_action(::proto::Action* action);

  // optional .proto.GameState gamestate = 3;
  bool has_gamestate() const;
  void clear_gamestate();
  static const int kGamestateFieldNumber = 3;
  const ::proto::GameState& gamestate() const;
  ::proto::GameState* mutable_gamestate();
  ::proto::GameState* release_gamestate();
  void set_allocated_gamestate(::proto::GameState* gamestate);

  // optional int32 byte_size = 5;
  void clear_byte_size();
  static const int kByteSizeFieldNumber = 5;
  ::google::protobuf::int32 byte_size() const;
  void set_byte_size(::google::protobuf::int32 value);

  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:proto.PokerMessage)
 private:
  inline void set_has_action();
  inline void set_has_gamestate();

  inline bool has_content() const;
  void clear_content();
  inline void clear_has_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int type_;
  ::google::protobuf::int32 byte_size_;
  union ContentUnion {
    ContentUnion() {}
    ::proto::Action* action_;
    ::proto::GameState* gamestate_;
  } content_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_poker_2eproto();
  friend void protobuf_AssignDesc_poker_2eproto();
  friend void protobuf_ShutdownFile_poker_2eproto();

  void InitAsDefaultInstance();
  static PokerMessage* default_instance_;
};
// -------------------------------------------------------------------

class Action : public ::google::protobuf::Message {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();

  void Swap(Action* other);

  // implements Message ----------------------------------------------

  inline Action* New() const { return New(NULL); }

  Action* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Action* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Action_ActionType ActionType;
  static const ActionType NONE = Action_ActionType_NONE;
  static const ActionType FOLD = Action_ActionType_FOLD;
  static const ActionType CHECK = Action_ActionType_CHECK;
  static const ActionType CALL = Action_ActionType_CALL;
  static const ActionType RAISE = Action_ActionType_RAISE;
  static const ActionType ALLIN = Action_ActionType_ALLIN;
  static inline bool ActionType_IsValid(int value) {
    return Action_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    Action_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    Action_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    Action_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return Action_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return Action_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return Action_ActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .proto.Action.ActionType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::proto::Action_ActionType type() const;
  void set_type(::proto::Action_ActionType value);

  // optional int32 bet = 2;
  void clear_bet();
  static const int kBetFieldNumber = 2;
  ::google::protobuf::int32 bet() const;
  void set_bet(::google::protobuf::int32 value);

  // optional int32 table_id = 3;
  void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  ::google::protobuf::int32 table_id() const;
  void set_table_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.Action)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int type_;
  ::google::protobuf::int32 bet_;
  ::google::protobuf::int32 table_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_poker_2eproto();
  friend void protobuf_AssignDesc_poker_2eproto();
  friend void protobuf_ShutdownFile_poker_2eproto();

  void InitAsDefaultInstance();
  static Action* default_instance_;
};
// -------------------------------------------------------------------

class Card : public ::google::protobuf::Message {
 public:
  Card();
  virtual ~Card();

  Card(const Card& from);

  inline Card& operator=(const Card& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Card& default_instance();

  void Swap(Card* other);

  // implements Message ----------------------------------------------

  inline Card* New() const { return New(NULL); }

  Card* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Card& from);
  void MergeFrom(const Card& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Card* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.Suite suite = 1;
  void clear_suite();
  static const int kSuiteFieldNumber = 1;
  ::proto::Suite suite() const;
  void set_suite(::proto::Suite value);

  // optional .proto.Rank rank = 2;
  void clear_rank();
  static const int kRankFieldNumber = 2;
  ::proto::Rank rank() const;
  void set_rank(::proto::Rank value);

  // @@protoc_insertion_point(class_scope:proto.Card)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int suite_;
  int rank_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_poker_2eproto();
  friend void protobuf_AssignDesc_poker_2eproto();
  friend void protobuf_ShutdownFile_poker_2eproto();

  void InitAsDefaultInstance();
  static Card* default_instance_;
};
// -------------------------------------------------------------------

class Player : public ::google::protobuf::Message {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();

  void Swap(Player* other);

  // implements Message ----------------------------------------------

  inline Player* New() const { return New(NULL); }

  Player* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Player* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional int32 stack = 2;
  void clear_stack();
  static const int kStackFieldNumber = 2;
  ::google::protobuf::int32 stack() const;
  void set_stack(::google::protobuf::int32 value);

  // optional .proto.Action latest_action = 3;
  bool has_latest_action() const;
  void clear_latest_action();
  static const int kLatestActionFieldNumber = 3;
  const ::proto::Action& latest_action() const;
  ::proto::Action* mutable_latest_action();
  ::proto::Action* release_latest_action();
  void set_allocated_latest_action(::proto::Action* latest_action);

  // optional uint64 hand = 5;
  void clear_hand();
  static const int kHandFieldNumber = 5;
  ::google::protobuf::uint64 hand() const;
  void set_hand(::google::protobuf::uint64 value);

  // optional string name = 6;
  void clear_name();
  static const int kNameFieldNumber = 6;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:proto.Player)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 stack_;
  ::proto::Action* latest_action_;
  ::google::protobuf::uint64 hand_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_poker_2eproto();
  friend void protobuf_AssignDesc_poker_2eproto();
  friend void protobuf_ShutdownFile_poker_2eproto();

  void InitAsDefaultInstance();
  static Player* default_instance_;
};
// -------------------------------------------------------------------

class GameState : public ::google::protobuf::Message {
 public:
  GameState();
  virtual ~GameState();

  GameState(const GameState& from);

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameState& default_instance();

  void Swap(GameState* other);

  // implements Message ----------------------------------------------

  inline GameState* New() const { return New(NULL); }

  GameState* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameState& from);
  void MergeFrom(const GameState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Player players = 1;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 1;
  const ::proto::Player& players(int index) const;
  ::proto::Player* mutable_players(int index);
  ::proto::Player* add_players();
  ::google::protobuf::RepeatedPtrField< ::proto::Player >*
      mutable_players();
  const ::google::protobuf::RepeatedPtrField< ::proto::Player >&
      players() const;

  // optional int32 smallblind = 2;
  void clear_smallblind();
  static const int kSmallblindFieldNumber = 2;
  ::google::protobuf::int32 smallblind() const;
  void set_smallblind(::google::protobuf::int32 value);

  // optional int32 bigblind = 3;
  void clear_bigblind();
  static const int kBigblindFieldNumber = 3;
  ::google::protobuf::int32 bigblind() const;
  void set_bigblind(::google::protobuf::int32 value);

  // optional int32 minimum_bet = 4;
  void clear_minimum_bet();
  static const int kMinimumBetFieldNumber = 4;
  ::google::protobuf::int32 minimum_bet() const;
  void set_minimum_bet(::google::protobuf::int32 value);

  // optional int32 pot = 5;
  void clear_pot();
  static const int kPotFieldNumber = 5;
  ::google::protobuf::int32 pot() const;
  void set_pot(::google::protobuf::int32 value);

  // optional int32 button = 6;
  void clear_button();
  static const int kButtonFieldNumber = 6;
  ::google::protobuf::int32 button() const;
  void set_button(::google::protobuf::int32 value);

  // optional int32 me = 7;
  void clear_me();
  static const int kMeFieldNumber = 7;
  ::google::protobuf::int32 me() const;
  void set_me(::google::protobuf::int32 value);

  // optional int32 whos_turn = 8;
  void clear_whos_turn();
  static const int kWhosTurnFieldNumber = 8;
  ::google::protobuf::int32 whos_turn() const;
  void set_whos_turn(::google::protobuf::int32 value);

  // optional int32 table_id = 9;
  void clear_table_id();
  static const int kTableIdFieldNumber = 9;
  ::google::protobuf::int32 table_id() const;
  void set_table_id(::google::protobuf::int32 value);

  // repeated .proto.Card community_cards = 10;
  int community_cards_size() const;
  void clear_community_cards();
  static const int kCommunityCardsFieldNumber = 10;
  const ::proto::Card& community_cards(int index) const;
  ::proto::Card* mutable_community_cards(int index);
  ::proto::Card* add_community_cards();
  ::google::protobuf::RepeatedPtrField< ::proto::Card >*
      mutable_community_cards();
  const ::google::protobuf::RepeatedPtrField< ::proto::Card >&
      community_cards() const;

  // @@protoc_insertion_point(class_scope:proto.GameState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::proto::Player > players_;
  ::google::protobuf::int32 smallblind_;
  ::google::protobuf::int32 bigblind_;
  ::google::protobuf::int32 minimum_bet_;
  ::google::protobuf::int32 pot_;
  ::google::protobuf::int32 button_;
  ::google::protobuf::int32 me_;
  ::google::protobuf::int32 whos_turn_;
  ::google::protobuf::int32 table_id_;
  ::google::protobuf::RepeatedPtrField< ::proto::Card > community_cards_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_poker_2eproto();
  friend void protobuf_AssignDesc_poker_2eproto();
  friend void protobuf_ShutdownFile_poker_2eproto();

  void InitAsDefaultInstance();
  static GameState* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PokerMessage

// optional .proto.MessageType type = 1;
inline void PokerMessage::clear_type() {
  type_ = 0;
}
inline ::proto::MessageType PokerMessage::type() const {
  // @@protoc_insertion_point(field_get:proto.PokerMessage.type)
  return static_cast< ::proto::MessageType >(type_);
}
inline void PokerMessage::set_type(::proto::MessageType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.PokerMessage.type)
}

// optional .proto.Action action = 2;
inline bool PokerMessage::has_action() const {
  return content_case() == kAction;
}
inline void PokerMessage::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void PokerMessage::clear_action() {
  if (has_action()) {
    delete content_.action_;
    clear_has_content();
  }
}
inline  const ::proto::Action& PokerMessage::action() const {
  // @@protoc_insertion_point(field_get:proto.PokerMessage.action)
  return has_action()
      ? *content_.action_
      : ::proto::Action::default_instance();
}
inline ::proto::Action* PokerMessage::mutable_action() {
  if (!has_action()) {
    clear_content();
    set_has_action();
    content_.action_ = new ::proto::Action;
  }
  // @@protoc_insertion_point(field_mutable:proto.PokerMessage.action)
  return content_.action_;
}
inline ::proto::Action* PokerMessage::release_action() {
  if (has_action()) {
    clear_has_content();
    ::proto::Action* temp = content_.action_;
    content_.action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PokerMessage::set_allocated_action(::proto::Action* action) {
  clear_content();
  if (action) {
    set_has_action();
    content_.action_ = action;
  }
  // @@protoc_insertion_point(field_set_allocated:proto.PokerMessage.action)
}

// optional .proto.GameState gamestate = 3;
inline bool PokerMessage::has_gamestate() const {
  return content_case() == kGamestate;
}
inline void PokerMessage::set_has_gamestate() {
  _oneof_case_[0] = kGamestate;
}
inline void PokerMessage::clear_gamestate() {
  if (has_gamestate()) {
    delete content_.gamestate_;
    clear_has_content();
  }
}
inline  const ::proto::GameState& PokerMessage::gamestate() const {
  // @@protoc_insertion_point(field_get:proto.PokerMessage.gamestate)
  return has_gamestate()
      ? *content_.gamestate_
      : ::proto::GameState::default_instance();
}
inline ::proto::GameState* PokerMessage::mutable_gamestate() {
  if (!has_gamestate()) {
    clear_content();
    set_has_gamestate();
    content_.gamestate_ = new ::proto::GameState;
  }
  // @@protoc_insertion_point(field_mutable:proto.PokerMessage.gamestate)
  return content_.gamestate_;
}
inline ::proto::GameState* PokerMessage::release_gamestate() {
  if (has_gamestate()) {
    clear_has_content();
    ::proto::GameState* temp = content_.gamestate_;
    content_.gamestate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PokerMessage::set_allocated_gamestate(::proto::GameState* gamestate) {
  clear_content();
  if (gamestate) {
    set_has_gamestate();
    content_.gamestate_ = gamestate;
  }
  // @@protoc_insertion_point(field_set_allocated:proto.PokerMessage.gamestate)
}

// optional int32 byte_size = 5;
inline void PokerMessage::clear_byte_size() {
  byte_size_ = 0;
}
inline ::google::protobuf::int32 PokerMessage::byte_size() const {
  // @@protoc_insertion_point(field_get:proto.PokerMessage.byte_size)
  return byte_size_;
}
inline void PokerMessage::set_byte_size(::google::protobuf::int32 value) {
  
  byte_size_ = value;
  // @@protoc_insertion_point(field_set:proto.PokerMessage.byte_size)
}

inline bool PokerMessage::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void PokerMessage::clear_has_content() {
  _oneof_case_[0] = CONTENT_NOT_SET;
}
inline PokerMessage::ContentCase PokerMessage::content_case() const {
  return PokerMessage::ContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Action

// optional .proto.Action.ActionType type = 1;
inline void Action::clear_type() {
  type_ = 0;
}
inline ::proto::Action_ActionType Action::type() const {
  // @@protoc_insertion_point(field_get:proto.Action.type)
  return static_cast< ::proto::Action_ActionType >(type_);
}
inline void Action::set_type(::proto::Action_ActionType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.Action.type)
}

// optional int32 bet = 2;
inline void Action::clear_bet() {
  bet_ = 0;
}
inline ::google::protobuf::int32 Action::bet() const {
  // @@protoc_insertion_point(field_get:proto.Action.bet)
  return bet_;
}
inline void Action::set_bet(::google::protobuf::int32 value) {
  
  bet_ = value;
  // @@protoc_insertion_point(field_set:proto.Action.bet)
}

// optional int32 table_id = 3;
inline void Action::clear_table_id() {
  table_id_ = 0;
}
inline ::google::protobuf::int32 Action::table_id() const {
  // @@protoc_insertion_point(field_get:proto.Action.table_id)
  return table_id_;
}
inline void Action::set_table_id(::google::protobuf::int32 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:proto.Action.table_id)
}

// -------------------------------------------------------------------

// Card

// optional .proto.Suite suite = 1;
inline void Card::clear_suite() {
  suite_ = 0;
}
inline ::proto::Suite Card::suite() const {
  // @@protoc_insertion_point(field_get:proto.Card.suite)
  return static_cast< ::proto::Suite >(suite_);
}
inline void Card::set_suite(::proto::Suite value) {
  
  suite_ = value;
  // @@protoc_insertion_point(field_set:proto.Card.suite)
}

// optional .proto.Rank rank = 2;
inline void Card::clear_rank() {
  rank_ = 0;
}
inline ::proto::Rank Card::rank() const {
  // @@protoc_insertion_point(field_get:proto.Card.rank)
  return static_cast< ::proto::Rank >(rank_);
}
inline void Card::set_rank(::proto::Rank value) {
  
  rank_ = value;
  // @@protoc_insertion_point(field_set:proto.Card.rank)
}

// -------------------------------------------------------------------

// Player

// optional int32 id = 1;
inline void Player::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Player::id() const {
  // @@protoc_insertion_point(field_get:proto.Player.id)
  return id_;
}
inline void Player::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:proto.Player.id)
}

// optional int32 stack = 2;
inline void Player::clear_stack() {
  stack_ = 0;
}
inline ::google::protobuf::int32 Player::stack() const {
  // @@protoc_insertion_point(field_get:proto.Player.stack)
  return stack_;
}
inline void Player::set_stack(::google::protobuf::int32 value) {
  
  stack_ = value;
  // @@protoc_insertion_point(field_set:proto.Player.stack)
}

// optional .proto.Action latest_action = 3;
inline bool Player::has_latest_action() const {
  return !_is_default_instance_ && latest_action_ != NULL;
}
inline void Player::clear_latest_action() {
  if (GetArenaNoVirtual() == NULL && latest_action_ != NULL) delete latest_action_;
  latest_action_ = NULL;
}
inline const ::proto::Action& Player::latest_action() const {
  // @@protoc_insertion_point(field_get:proto.Player.latest_action)
  return latest_action_ != NULL ? *latest_action_ : *default_instance_->latest_action_;
}
inline ::proto::Action* Player::mutable_latest_action() {
  
  if (latest_action_ == NULL) {
    latest_action_ = new ::proto::Action;
  }
  // @@protoc_insertion_point(field_mutable:proto.Player.latest_action)
  return latest_action_;
}
inline ::proto::Action* Player::release_latest_action() {
  
  ::proto::Action* temp = latest_action_;
  latest_action_ = NULL;
  return temp;
}
inline void Player::set_allocated_latest_action(::proto::Action* latest_action) {
  delete latest_action_;
  latest_action_ = latest_action;
  if (latest_action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Player.latest_action)
}

// optional uint64 hand = 5;
inline void Player::clear_hand() {
  hand_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Player::hand() const {
  // @@protoc_insertion_point(field_get:proto.Player.hand)
  return hand_;
}
inline void Player::set_hand(::google::protobuf::uint64 value) {
  
  hand_ = value;
  // @@protoc_insertion_point(field_set:proto.Player.hand)
}

// optional string name = 6;
inline void Player::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:proto.Player.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Player.name)
}
inline void Player::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Player.name)
}
inline void Player::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Player.name)
}
inline ::std::string* Player::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.Player.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_name() {
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.Player.name)
}

// -------------------------------------------------------------------

// GameState

// repeated .proto.Player players = 1;
inline int GameState::players_size() const {
  return players_.size();
}
inline void GameState::clear_players() {
  players_.Clear();
}
inline const ::proto::Player& GameState::players(int index) const {
  // @@protoc_insertion_point(field_get:proto.GameState.players)
  return players_.Get(index);
}
inline ::proto::Player* GameState::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:proto.GameState.players)
  return players_.Mutable(index);
}
inline ::proto::Player* GameState::add_players() {
  // @@protoc_insertion_point(field_add:proto.GameState.players)
  return players_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Player >*
GameState::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:proto.GameState.players)
  return &players_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Player >&
GameState::players() const {
  // @@protoc_insertion_point(field_list:proto.GameState.players)
  return players_;
}

// optional int32 smallblind = 2;
inline void GameState::clear_smallblind() {
  smallblind_ = 0;
}
inline ::google::protobuf::int32 GameState::smallblind() const {
  // @@protoc_insertion_point(field_get:proto.GameState.smallblind)
  return smallblind_;
}
inline void GameState::set_smallblind(::google::protobuf::int32 value) {
  
  smallblind_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.smallblind)
}

// optional int32 bigblind = 3;
inline void GameState::clear_bigblind() {
  bigblind_ = 0;
}
inline ::google::protobuf::int32 GameState::bigblind() const {
  // @@protoc_insertion_point(field_get:proto.GameState.bigblind)
  return bigblind_;
}
inline void GameState::set_bigblind(::google::protobuf::int32 value) {
  
  bigblind_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.bigblind)
}

// optional int32 minimum_bet = 4;
inline void GameState::clear_minimum_bet() {
  minimum_bet_ = 0;
}
inline ::google::protobuf::int32 GameState::minimum_bet() const {
  // @@protoc_insertion_point(field_get:proto.GameState.minimum_bet)
  return minimum_bet_;
}
inline void GameState::set_minimum_bet(::google::protobuf::int32 value) {
  
  minimum_bet_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.minimum_bet)
}

// optional int32 pot = 5;
inline void GameState::clear_pot() {
  pot_ = 0;
}
inline ::google::protobuf::int32 GameState::pot() const {
  // @@protoc_insertion_point(field_get:proto.GameState.pot)
  return pot_;
}
inline void GameState::set_pot(::google::protobuf::int32 value) {
  
  pot_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.pot)
}

// optional int32 button = 6;
inline void GameState::clear_button() {
  button_ = 0;
}
inline ::google::protobuf::int32 GameState::button() const {
  // @@protoc_insertion_point(field_get:proto.GameState.button)
  return button_;
}
inline void GameState::set_button(::google::protobuf::int32 value) {
  
  button_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.button)
}

// optional int32 me = 7;
inline void GameState::clear_me() {
  me_ = 0;
}
inline ::google::protobuf::int32 GameState::me() const {
  // @@protoc_insertion_point(field_get:proto.GameState.me)
  return me_;
}
inline void GameState::set_me(::google::protobuf::int32 value) {
  
  me_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.me)
}

// optional int32 whos_turn = 8;
inline void GameState::clear_whos_turn() {
  whos_turn_ = 0;
}
inline ::google::protobuf::int32 GameState::whos_turn() const {
  // @@protoc_insertion_point(field_get:proto.GameState.whos_turn)
  return whos_turn_;
}
inline void GameState::set_whos_turn(::google::protobuf::int32 value) {
  
  whos_turn_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.whos_turn)
}

// optional int32 table_id = 9;
inline void GameState::clear_table_id() {
  table_id_ = 0;
}
inline ::google::protobuf::int32 GameState::table_id() const {
  // @@protoc_insertion_point(field_get:proto.GameState.table_id)
  return table_id_;
}
inline void GameState::set_table_id(::google::protobuf::int32 value) {
  
  table_id_ = value;
  // @@protoc_insertion_point(field_set:proto.GameState.table_id)
}

// repeated .proto.Card community_cards = 10;
inline int GameState::community_cards_size() const {
  return community_cards_.size();
}
inline void GameState::clear_community_cards() {
  community_cards_.Clear();
}
inline const ::proto::Card& GameState::community_cards(int index) const {
  // @@protoc_insertion_point(field_get:proto.GameState.community_cards)
  return community_cards_.Get(index);
}
inline ::proto::Card* GameState::mutable_community_cards(int index) {
  // @@protoc_insertion_point(field_mutable:proto.GameState.community_cards)
  return community_cards_.Mutable(index);
}
inline ::proto::Card* GameState::add_community_cards() {
  // @@protoc_insertion_point(field_add:proto.GameState.community_cards)
  return community_cards_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Card >*
GameState::mutable_community_cards() {
  // @@protoc_insertion_point(field_mutable_list:proto.GameState.community_cards)
  return &community_cards_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Card >&
GameState::community_cards() const {
  // @@protoc_insertion_point(field_list:proto.GameState.community_cards)
  return community_cards_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::Action_ActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::Action_ActionType>() {
  return ::proto::Action_ActionType_descriptor();
}
template <> struct is_proto_enum< ::proto::MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::MessageType>() {
  return ::proto::MessageType_descriptor();
}
template <> struct is_proto_enum< ::proto::Rank> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::Rank>() {
  return ::proto::Rank_descriptor();
}
template <> struct is_proto_enum< ::proto::Suite> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::Suite>() {
  return ::proto::Suite_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_poker_2eproto__INCLUDED
