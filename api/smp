// -*-C++-*-

#pragma once
#ifndef API_SMP_HEADER
#define API_SMP_HEADER

#include <delegate>
#include <vector>
#include <smp_utils>

// access a container of T by current CPU id
#define PER_CPU(x) x.at(SMP::cpu_id())


class SMP {
public:
  using task_func = delegate<void()>;
  using done_func = delegate<void()>;

  // return the current CPU id
  static int cpu_id() noexcept;

  // return the number of active CPUs
  static int cpu_count() noexcept;

  // Return the indices of all initialized CPU cores
  static const std::vector<int>& active_cpus();

  // implement this function to execute something on all APs at init
  static void init_task();

  // execute @task on another CPU core
  // optionally call @done back on main CPU after running task
  // use SMP::signal() to broadcast when work should begin
  // if cpu == 0, the first free signalled CPU will grab the work
  static bool add_task(task_func task, done_func done, int cpu = 0);
  static bool add_task(task_func task, int cpu = 0);
  // execute a function on the main cpu
  static bool add_bsp_task(done_func done);

  // call this to signal that tasks are queued up
  // if cpu == 0, broadcast signal to all CPUs
  static void signal(int cpu = 0);
  static void signal_bsp();

  // trigger single interrupt on specified CPU
  static void unicast(int cpu, uint8_t intr);
  // broadcast-trigger interrupt on all CPUs
  static void broadcast(uint8_t intr);
  // spuriously wake a CPU (from sleeping), works on all CPUs
  static void wake(int cpu);

  // a global spinlock to synchronize text output (primarily)
  static void global_lock()   noexcept;
  static void global_unlock() noexcept;

  // during startup we can use this function to size up dynamic arrays
  static size_t early_cpu_total() noexcept;

  // activate or deactivate automatic migration of new threads for,
  // the current CPU, by moving them to the first free CPU.
  // this setting is active on a per-CPU basis.
  static void migrate_threads(bool enable = true);
  static void migrate_threads_to(int cpu);
};

#include <array>
template <typename T, size_t N>
inline T& per_cpu_help(std::array<T, N>& array)
{
    return array.at(SMP::cpu_id());
}

#include <util/fixed_vector.hpp>
namespace kernel {
	extern Fixed_vector<delegate<void()>, 64> smp_global_init;
}

#define SMP_RESIZE_NOW(x) x.resize(SMP::early_cpu_total())

#define SMP_RESIZE_EARLY_GCTOR(x) \
    static struct smp_gctor_##x { \
		smp_gctor_##x() { \
			kernel::smp_global_init.push_back( \
				[] () { \
					SMP_RESIZE_NOW(x); \
				}); \
		} \
	} smp_gctor_##x_instance;

#define SMP_RESIZE_LATE_GCTOR(x) \
    static struct smp_gctor_##x { \
		smp_gctor_##x() { \
      SMP_RESIZE_NOW(x); \
		} \
	} smp_gctor_##x_instance;

#define SMP_ALIGN       64
#define SMP_MAX_CORES  256


namespace smp {
	extern std::vector<int> initialized_cpus;
}

/// implementation of the SMP interface ///
inline int SMP::cpu_id() noexcept
{
  int cpuid;
#ifdef ARCH_x86_64
  asm("movl %%gs:(0x0), %0" : "=r" (cpuid));
#elif defined(ARCH_i686)
  asm("movl %%fs:(0x0), %0" : "=r" (cpuid));
#else
  asm("mrs %0, mpidr_el1" : "=r" (cpuid));
  cpuid &= 0xFF;
#endif
  return cpuid;
}

inline int SMP::cpu_count() noexcept {
  return smp::initialized_cpus.size();
}

inline const std::vector<int>& SMP::active_cpus() {
  return smp::initialized_cpus;
}

#endif
